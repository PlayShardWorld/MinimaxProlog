% Циклы для заполнения БД
%
% size(Size), for(1, Size), % Заполнение поля
% nondeterm for(integer, integer) % Цикл for
% nondeterm for2(integer, integer, integer) % Цикл for
% for2(I, N, R):- I > N, !; КОСТЫЛИ
%	write(R, " ", I, "\n"), assert(field(R, I, "_")), 
%	I1 = I + 1, for2(I1, N, R).
% for(I, N):- I > N, !;
%	size(Size), for2(1, Size, I),
%	I1 = I + 1, for(I1, N).
%

/*
Хранимые значения:
1. Игровое поле
2. Тип фишки человека
3. Тип фишки компьютера

Набор необходимых предикат:
0. Проверка случая победы
1. Установить фишку по индексу
2. Получить фишку по индексу
3. Проверить фишку по индексу
4. Сделать ход
5. Проверить свободные поля
6. Метод минимакса
7. Перевод числа в координаты
8. Генерирование возможных ходов (СП)
9. Выбор лучшего хода из сгенерированных (СП)
10. Поиск любых возможных ходов (СП)
11. Вычисление стоимости хода (больше - лучше, для минимакса)

Набор отладочных предикат:
1. Вывод поля на экран
*/
%===============================================================================
domains
ilist = integer*
slist = symbol*

database 
board(integer, integer, symbol)
boardsize(integer)
winlength(integer)
pchip(symbol)
cchip(symbol)

predicates
% Инициализация игрового поля
initialization 
initialization(integer)

% Проверка свободных полей
checkfree

% Проверка наличия победы
checkwin(symbol)
checkwin(symbol, integer)

maxlength(symbol, integer, integer, integer) % i i i o
maxlength(symbol, integer, integer, integer, integer, integer) % i o
maxlength(symbol, integer, integer, integer, integer, integer, integer) % i o

max(integer, integer, integer, integer, integer)

% Отображение игрового поля
show 
show(integer)

get(integer, integer, symbol)
	% integer - координата по X
	% integer - координата по Y
	% symbol - сюда будет помещено хранимое значение
	
set(integer, integer, symbol)
	% integer - координата по X
	% integer - координата по Y
	% symbol - этот символ будет помещён на своё место
	
del(integer, integer, symbol)
	% integer - координата по X
	% integer - координата по Y
	% symbol - символ
	
turn(integer)
	% integer - номер игрока, чей производится ход
	
unfold(integer, integer, integer) % Перевод числа в координаты
	% integer - номер элемента
	% integer - координата по X
	% integer - координата по Y
	
minimax(slist, symbol, integer, integer, integer)
	% integer - глубина поиска решения
	% integer - следующий лучший ход
	% integer - значение
	
genmoves(slist, symbol, ilist)
	% ilist - список возможных ходов
genmoves(slist, symbol, ilist, integer, integer)
	% ilist - список возможных ходов
	% integer - рассматриваемый ход
	% integer - количество найденных ходов

choose(slist, symbol, integer, ilist, integer, integer)
	% integer - глубина поиска
	% ilist - список возможных ходов
	% integer - выбранный ход
	% integer - вес хода
	
findfree(slist, integer, ilist)
	% ilist - список пустых ходов
	% integer - рассматриваемый ход
	
% Перевод поля в список
tolist(slist)
tolist(slist, integer)

opponent(symbol, symbol)
max(integer, integer, integer, integer, integer, integer)
value(slist, symbol, integer, integer)
good(slist, symbol, integer)
set(slist, integer, symbol, slist) % Создание нового списка и измененными значениями
	% list - игровое поле
	% integer - номер в списке
	% symbol - записываемый символ
	% list - новое игровое поле
	
	
	
	
	
	
	
sget(slist, integer, symbol) % Получение символа по номеру из списка
	% list - игровое поле
	% integer - номер в списке
	% symbol - отсюда будет взят символ
sget(slist, integer, integer, symbol) % Получение символа по индексам из списка
	% list - игровое поле
	% integer - индекс по X
	% integer - индекс по Y
	% symbol - отсюда будет взят символ	
	
nonblocking(symbol, symbol)		
points(integer, integer) % Расчёт очков за ряд
points(slist, integer, integer, symbol, integer)
points(slist, integer, integer, symbol, integer, integer, integer)
points(slist, integer, integer, symbol, integer, integer, integer, integer)	
open(integer, integer) % Расчёт очков за ряд с учётом открытых полей
open(slist, integer, integer, symbol, integer)
open(slist, integer, integer, symbol, integer, integer, integer)
open(slist, integer, integer, symbol, integer, integer, integer, integer)	
	
	
	
	
	
	
	
	
	
	
	
	
clauses
%==============================================================================%
% Обязательная часть игры
%==============================================================================%
% Инициализация игрового поля размером Size*Size
initialization:-
	boardsize(Size),
	N = Size * Size - 1,
	initialization(N), !.
initialization(-1):- !.
initialization(N):-
	boardsize(Size),
	X = N mod Size,
	Y = (N - X) div Size,
	set(X, Y, "_"),
	N1 = N - 1,
	initialization(N1), !.
%==============================================================================%
% Получение и проверка символа по заданным индексам
get(X, Y, F):- board(X, Y, F), !.
%==============================================================================%
% Установка символа по заданным индексам
set(X, Y, F):- assert(board(X, Y, F)), !.
%==============================================================================%
% Удаление символа по заданным индексам
del(X, Y, F):- retract(board(X, Y, F)), !.
%==============================================================================%
% Проверка поля на пустые символы (доступные ходы)
checkfree:- board(_, _, "_"), !.
%==============================================================================%
% Проверка поля на наличие победных комбинаций
checkwin(F):- % Проверка для всех заполненных клеток
	boardsize(Size),
	N = Size * Size - 1,
	checkwin(F, N), !.
% Если поле закончилось - труе
checkwin(_, -1):- !.
checkwin(F, N):-
	% Вызываем ml для каждой клетки
	boardsize(Size),
	X = N mod Size,
	Y = (N - X) div Size,
	get(X, Y, F), % проверка, что в клетке символ
	maxlength(F, X, Y, Length), % Получаем длину комбинации для клетки X:Y
	winlength(WLength),
	Length >= WLength, 
	write("Обнаружена выигрышная длина\n"), !.
	%write("Длина: ", Length), nl,
	%Length < WLength,
	%N1 = N - 1,
	%checkwin(F, N1), !.
checkwin(F, N):-
	% Проверка что символ был пустым
	%get(X, Y, "_"),
	%write(N), nl,
	N1 = N - 1,
	checkwin(F, N1), !.

% Length - необходимая длина для победы
% N - Номер рассматриваемой клетки в списке
maxlength(F, X, Y, Length):-
	get(X, Y, F),
	maxlength(F, X, Y, 1, 0, L1), % Проверка по горизонтали
	maxlength(F, X, Y, 0, 1, L2), % Проверка по вертикали
	maxlength(F, X, Y, 1, 1, L3), % Проверка по диагонали
	maxlength(F, X, Y, 1, -1, L4), % Проверка по диагонали
	max(L1, L2, L3, L4, Length). % Получаем максимальную длину
	
maxlength(F, X, Y, DX, DY, Length):-
	maxlength(F, X, Y, DX, DY, 1, L1),
	MDX = -DX, MDY = -DY,
	maxlength(F, X, Y, MDX, MDY, 1, L2),
	Length = L1 + L2 + 1. % Получение длины

maxlength(_, _, _, _, _, L, 0):-
	winlength(WL),
	WL = L, !.
maxlength(F, X, Y, DX, DY, D, Length):-
	X1 = X + DX * D, % Получение новой позиции по X
	Y1 = Y + DY * D, % Получение новой позиции по Y
	get(X1, Y1, F), % Проверка символа клетки на совпадение с символом игрока
	D1 = D + 1,
	maxlength(F, X, Y, DX, DY, D1, Length1),
	Length = Length1 + 1, !.
maxlength(_, _, _, _, _, _, 0).
	
max(A, B, C, D, A):- A >= B, A >= C, A >= D, !.
max(A, B, C, D, B):- B >= A, B >= C, B >= D, !.
max(A, B, C, D, C):- C >= A, C >= B, C >= D, !.
max(A, B, C, D, D):- D >= A, D >= B, D >= C, !.
%==============================================================================%
% Перевод номера в списке в координаты
unfold(M, X, Y):-
	boardsize(Size),
	X = M mod Size,
	Y = (M - X) div Size, !.
%==============================================================================%
% Сбор всех доступных ходов
% Списочный вариант поиска доступных ходов
findfree([], _, []).
findfree([H|T], N, [N|RT]):-
	H = "_",
	N1 = N + 1,
	findfree(T, N1, RT), !.
findfree([H|T], N, RT):-
	N1 = N + 1,
	findfree(T, N1, RT).
/*
findfree(ML):-
	boardsize(Size),
	N = Size * Size - 1,
	findfree(ML, N), !.
findfree([], -1):- !.
findfree([N|T], N):-
	boardsize(Size),
	X = N mod Size,       % получаем координату по X
	Y = (N - X) div Size, % получаем координату по Y
	get(X, Y, "_"), % проверка на пустоту
	N1 = N - 1,
	findfree(T, N1), !.
findfree(T, N):-
	N1 = N - 1,
	findfree(T, N1), !.
	
*/
%==============================================================================%
% Установка символа в списке по номеру
set([_|T], 0, X, [X|T]):- !.
set([H|T], N, X, [H|R]):- % Составляем новое поле с изменёнными значениями
	N1 = N - 1,
	set(T, N1, X, R). % Рекурсивный вызов предиката
%==============================================================================%
% Генератор возможных ходов
% B - игровое поле
% F - символ текущего игрока
% ML - список доступных ходов
% i i o
genmoves(B, F, ML):- 
	genmoves(B, F, ML, 0, MC), % генерируем ходы
	MC > 0, !.
genmoves(B, F, ML):-
	findfree(B, 0, ML). % ищем любые доступные ходы
	
% N - номер проверяемой клетки
% MC - ???
% i i o i o тут неточно, код был написан пару дней назад и незадокументирован
genmoves(B, F, [], N, 0):-
	boardsize(Size),
	N = Size * Size, !.
genmoves(B, F, [N|T], N, MC):-
	good(B, F, N), % Проверка хода на адекватность
	N1 = N + 1, % берём следующую клетку
	genmoves(B, F, T, N1, MC1),
	MC = MC1 + 1, !. % увеличиваем количество полученных ходов на 1
genmoves(B, F, T, N, MC):-
	N1 = N + 1, % берём следующую клетку
	genmoves(B, F, T, N1, MC).
%==============================================================================%
% Выбор лучшего хода
% B - поле
% F - фишка текущего игрока
% D - глубина поиска минимакса
% ML ([H|T]) - список ходов
% M - выбранный ход минимакса
% V - стоимость хода
% i i i i o o
choose(_, _, _, [], -1, -999):- !. % Случай, когда не из чего выбирать
choose(B, F, D, [H|T], M, V):-
	value(B, F, H, V1), % Расчёт очков для хода 'H'
	set(B, H, F, NB), % Установка нового символа
	opponent(F, FO), % В этом месте раскрывается суть минимакса (лучший для меня - худший для компьютера)
	D1 = D - 1,
	minimax(NB, FO, D1, _, V2), % Вызов минимакса с новым полем для оппонента
	VH = V1 - V2, % Для пары хода %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	choose(B, F, D, T, MT, VT),
	max(VH, H, VT, MT, V, M).
%==============================================================================%
max(VH, H, VT, MT, VH, H):-
	VH > VT, !.
max(_, _, VT, MT, VT, MT).
%==============================================================================%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Расчёт очков хода
% Фактически: М - атака, О - защита
value(B, F, M, Points):- % M - ход минимакса, P - очки хода
	unfold(M, X, Y),
	points(B, X, Y, F, RPoM),
	open(B, X, Y, F, ROpM),
	%Points = 9 * RPoM + 3 * ROpM, !. % Только с учётом атаки
	opponent(F, FO),
	points(B, X, Y, FO, RPoO),
	open(B, X, Y, FO, ROpO),
	Points = 17 * RPoM + 35 * RPoO + 3 * ROpM + 2 * ROpO, !. % + защита
%==============================================================================%
good(B, F, M):-
	value(B, F, M, P),
	P > 25. % Магическая цифра из статьи tproger (18 - 1) чем больше тем точнее
%==============================================================================%
opponent("X", "O").
opponent("O", "X").
%==============================================================================%
% Перевод поля в список
tolist(BL):- tolist(BL, 0), !.
tolist([], N):- 
	boardsize(Size),
	N = Size * Size, !.
tolist([H|BL], N):-
	boardsize(Size),
	X = N mod Size,
	Y = (N - X) div Size,
	get(X, Y, H),
	N1 = N + 1,
	tolist(BL, N1), !.
%==============================================================================%
% Моя фишка или открытое поле
nonblocking("_", _):- !.
nonblocking(A, A):- !.
%==============================================================================%
% Получение или проверка символа из/в списке [H]
% i i o/i
sget([H|_], 0, H):- !.
sget([_|T], N, R):- % Проходим по списку, чтобы вытащить необходимый символ
	N1 = N - 1,
	sget(T, N1, R), !. % Рекурсивный вызов предиката
sget(B, X, Y, R):-
	boardsize(S),
	-1 < X, X < S, % Проверяем, что индекс по X допустим
	-1 < Y, Y < S, % Проверяем, что индекс по Y допустим
	N = X + S * Y, % Получаем номер символа в списке
	sget(B, N, R), !. % Получаем символ и записываем его в R
%==============================================================================%
% Кодярина
% B - игровое поле (Board)
% X - координата по X
% Y - координата по Y
% F - фишка игрока (fishka ???)
% P - очки (Points)
% i i i i o
points(B, X, Y, F, Points):-
	sget(B, X, Y, "_"), % Проверяем клетку [X:Y] на пустоту
	points(B, X, Y, F, 1, 0, P1),  % Проверка по горизонтали [6]
	points(B, X, Y, F, 0, 1, P2),  % Проверка по вертикали   [8]
	points(B, X, Y, F, 1, 1, P3),  % Проверка по диагонали   [68]
	points(B, X, Y, F, 1, -1, P4), % Проверка по диагонали   [62]
	Points = P1 + P2 + P3 + P4. % Суммируем полученные очки
	
% DX - смещение по X
% DY - смещение по Y
% i i i i i i o	
points(B, X, Y, F, DX, DY, Points):-
	points(B, X, Y, F, DX, DY, 1, P1), % Проверка вперёд (вверх-вправо(3))
	MDX = -DX, MDY = -DY,
	points(B, X, Y, F, MDX, MDY, 1, P2), % Проверка назад (вниз-влево(3))
	PS = P1 + P2 + 1, % Получение длины составленного ряда
	points(PS, Points). % Перевод в очки
	
% D - начальная длина ряда
% N - длина ряда
% i i i i i i i o
points(_, _, _, _, _, _, 4, 0):- !. % Поиск комбинаций, не длинее чем D клет[ки/ок]
points(B, X, Y, F, DX, DY, D, N):-
	X1 = X + DX * D, % Получение новой позиции по X
	Y1 = Y + DY * D, % Получение новой позиции по Y
	sget(B, X1, Y1, F), % Проверка символа клетки на совпадение с символом игрока
	D1 = D + 1,
	points(B, X, Y, F, DX, DY, D1, N1), % Рекурсивный вызов проверки
	N = N1 + 1, !. % Добавление единицы к длине ряда
points(_, _, _, _, _, _, _, 0).

% i o
points(1, 0):- !. % Если ряд не образован - 0 очков
points(N, Points):- Points = N - 2. % Перевод длины ряда в очки
%==============================================================================%
% B - игровое поле (Board)
% X - координата по X
% Y - координата по Y
% F - фишка игрока (fishka ???)
% P - очки (Points)
% i i i i o
open(B, X, Y, F, Points):-
	sget(B, X, Y, "_"), % Проверяем клетку [X:Y] на пустоту
	open(B, X, Y, F, 1, 0, P1),  % Проверка по горизонтали [6]
	open(B, X, Y, F, 0, 1, P2),  % Проверка по вертикали   [8]
	open(B, X, Y, F, 1, 1, P3),  % Проверка по диагонали   [68]
	open(B, X, Y, F, 1, -1, P4), % Проверка по диагонали   [62]
	Points = P1 + P2 + P3 + P4. % Суммируем полученные очки
	
% DX - смещение по X
% DY - смещение по Y
% i i i i i i o	
open(B, X, Y, F, DX, DY, Points):-
	open(B, X, Y, F, DX, DY, 1, P1), % Проверка вперёд (вверх-вправо(3))
	MDX = -DX, MDY = -DY,
	open(B, X, Y, F, MDX, MDY, 1, P2), % Проверка назад (вниз-влево(3))
	PS = P1 + P2 + 1, % Получение длины составленного ряда
	open(PS, Points). % Перевод в очки
	
% D - начальная длина ряда
% N - длина ряда
% i i i i i i i o
open(_, _, _, _, _, _, 4, 0):- !. % Поиск комбинаций, не длинее чем D клет[ки/ок]
open(B, X, Y, F, DX, DY, D, N):-
	X1 = X + DX * D, % Получение новой позиции по X
	Y1 = Y + DY * D, % Получение новой позиции по Y
	sget(B, X1, Y1, M), % Запись значения выбранной клетки в M
	nonblocking(M, F),  % Проверка клетки на совпадение или на пустоту
	D1 = D + 1,
	open(B, X, Y, F, DX, DY, D1, N1), % Рекурсивный вызов проверки
	N = N1 + 1, !. % Добавление единицы к длине ряда
open(_, _, _, _, _, _, _, 0).

% i o
open(1, 0):- !. % Если ряд не образован - 0 очков
open(N, Points):- Points = N - 2. % Перевод длины ряда в очки
%==============================================================================%
% Минимакс
minimax(B, F, _, 4, 0):- % ход в середину, если она свободна
	boardsize(3),
	get(1, 1, "_"), !.
minimax(B, F, 0, -1, 0):- !. %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
minimax(B, F, D, M, V):-
	%write("Minimax"), nl,
	genmoves(B, F, ML), % генерируем возможные ходы и записываем их в ML
	%write(ML),
	choose(B, F, D, ML, M, V). % выбираем лучший ход
%==============================================================================%
% Ходы
turn(0):-
	checkfree, % Проверка на доступные поля
	cchip(F),  % Получение фишки человека
	write("Ход компьютера: "),
	tolist(BL), % перевод доски в список
	minimax(BL, "O", 3, M, _), % Запуск метода минимакса для поиска хода
	unfold(M, X, Y), % Перевод значения в координаты
  	write(X, Y), nl,
  	del(X, Y, "_"), !,
  	set(X, Y, F),
  	show,
  	%maxlength("O", 2, 2, Length), write("Длина: ", Length),
  	turn(1).

% Ход человека
turn(1):-
	checkfree, % Проверка на доступные поля
	pchip(F),  % Получение фишки человека
	write("Ход человека.\n"),
	boardsize(Size),
	write("Номер ряда (от 0 до ", Size, "-1): "), readint(Y), 
	Y >= 0, Y < Size,
  	write("Номер столбца (от 0 до ", Size, "-1): "), readint(X),
  	X >= 0, X < Size,
  	del(X, Y, "_"), !,
  	set(X, Y, F),
  	show,
  	checkwin(F),
  	%maxlength("X", 2, 2, Length), write("Длина: ", Length), nl,
  	%tolist(NL),
  	turn(0).
  	
% Случай, если закончились поля и нет победителя
turn(_):- 
	not(checkfree),
	write("Ничья!\n"). 
%==============================================================================%
show:-
	boardsize(Size),
	N = Size * Size - 1,
	show(N), !.
show(-1):- !.
show(N):- % Случай для переноса строки на новую
	boardsize(Size),
	X = Size - (N mod Size) - 1,
	Y = Size - (N div Size) - 1,
	X = Size - 1,
	write(Y, X, " "),
	get(X, Y, F),
	write(F, " "), nl,
	N1 = N - 1,
	show(N1), !.
show(N):-
	boardsize(Size),
	X = Size - (N mod Size) - 1,
	Y = Size - (N div Size) - 1,
	write(Y, X, " "),
	get(X, Y, F),
	write(F, " "),
	N1 = N - 1,
	show(N1), !.
	
goal
	assert(boardsize(5)), % Указание размера поля
	assert(winlength(3)), % Указание размера выигрышного ряда
	assert(pchip("X")), % Установка фишки человека
	assert(cchip("O")), % Установка фишки компьютера
	initialization, show,
	turn(1); % Первым ходит человек
	%checkwin(3), write("ПОБЕДА КОГО-ТО ТАМ"), nl, fail;
	write("\nКонец игры"), nl, fail.